import discord
from discord.ext import commands, tasks
from discord import app_commands
from yt_dlp import YoutubeDL
from discord import FFmpegPCMAudio
import spotipy
from spotipy.oauth2 import SpotifyClientCredentials
import asyncio
from discord.ui import View, Button
import random
import json, os

# ------------------------
# Spotify Setup
# ------------------------
SPOTIFY_CLIENT_ID = "9966109f1afc4e8fb45113808b1a6dc7"
SPOTIFY_CLIENT_SECRET = "1b7cfbbd75ab4e70a6d1b26a053859fd"

sp = spotipy.Spotify(auth_manager=SpotifyClientCredentials(
    client_id=SPOTIFY_CLIENT_ID,
    client_secret=SPOTIFY_CLIENT_SECRET
))

# ------------------------
# Bot Setup
# ------------------------
intents = discord.Intents.default()
intents.message_content = True
intents.voice_states = True
intents.members = True

bot = commands.Bot(command_prefix="!", intents=intents)

song_queues = {}          # guild_id: list of URLs
song_info_cache = {}      # guild_id: current song info
now_playing_msg = {}      # guild_id: message object for updating progress
volumes = {}              # guild_id: volume (0.0-1.0)
idle_disconnect_times = {} # guild_id: idle seconds

YDL_OPTIONS = {
    'format': 'bestaudio/best',
    'noplaylist': False,       # keep playlist support
    'quiet': True,
    'no_warnings': True,
    'cachedir': False,         # disables persistent cache
    'extract_flat': False,     # ensures we get direct URL to audio
}

FFMPEG_OPTIONS = {
    'before_options': '-reconnect 1 -reconnect_streamed 1 -reconnect_delay_max 5',
    'options': '-vn'
}

# ------------------------
# Helpers
# ------------------------
def format_duration(seconds):
    if seconds is None:
        return "Unknown"
    m, s = divmod(int(seconds), 60)
    h, m = divmod(m, 60)
    if h:
        return f"{h}:{m:02}:{s:02}"
    return f"{m}:{s:02}"

async def search_youtube(query):
    ydl_opts = {'format': 'bestaudio', 'noplaylist': True, 'quiet': True}
    with YoutubeDL(ydl_opts) as ydl:
        try:
            info = ydl.extract_info(f"ytsearch:{query}", download=False)['entries'][0]
            return info['webpage_url']
        except Exception:
            return None

# ------------------------
# Play Command
# ------------------------
# ------------------------
# /play command (rewritten)
# ------------------------
@bot.tree.command(name="play", description="Play a YouTube or Spotify track/playlist")
@app_commands.describe(url="YouTube or Spotify URL")
async def play(interaction: discord.Interaction, url: str):
    # Defer immediately to prevent interaction timeout
    await interaction.response.defer()
    
    guild_id = interaction.guild.id
    if guild_id not in song_queues:
        song_queues[guild_id] = []

    urls_to_add = []

    # Spotify link handling
    if "open.spotify.com" in url:
        try:
            if "track" in url:
                track = sp.track(url)
                query = f"{track['name']} {track['artists'][0]['name']}"
                yt_url = await search_youtube(query)
                if yt_url:
                    urls_to_add.append(yt_url)
            elif "playlist" in url:
                results = sp.playlist_items(url)
                for item in results['items']:
                    track = item['track']
                    query = f"{track['name']} {track['artists'][0]['name']}"
                    yt_url = await search_youtube(query)
                    if yt_url:
                        urls_to_add.append(yt_url)
        except Exception as e:
            await interaction.followup.send(f"Failed to process Spotify URL: {e}")
            return
    else:
        # Direct YouTube link
        urls_to_add.append(url)

    if not urls_to_add:
        await interaction.followup.send("No valid songs could be added.")
        return

    song_queues[guild_id].extend(urls_to_add)
    await interaction.followup.send(f"Added {len(urls_to_add)} song(s) to the queue.")

    # Start playing if not already
    vc = interaction.guild.voice_client
    if not vc or not vc.is_playing():
        await play_next(interaction, guild_id)

# ------------------------
# Search Command with Pagination (5 results per page)
# ------------------------
@bot.tree.command(name="search", description="Search YouTube and choose a song")
@app_commands.describe(query="Song name to search")
async def search(interaction: discord.Interaction, query: str):
    await interaction.response.defer()  # Acknowledge the command

    guild_id = interaction.guild.id
    if guild_id not in song_queues:
        song_queues[guild_id] = []

    page_size = 5

    async def get_results(query, page):
        """Fetch 5 results dynamically from YouTube using yt-dlp."""
        ydl_opts = {
            'format': 'bestaudio',
            'noplaylist': True,
            'quiet': True,
            'extract_flat': True,
        }
        with YoutubeDL(ydl_opts) as ydl:
            try:
                info = ydl.extract_info(f"ytsearch{page_size}:{query}", download=False)
                return info['entries']
            except Exception as e:
                print(f"yt-dlp search error: {e}")
                return []

    def make_embed(results, page):
        embed = discord.Embed(
            title=f"Search results for: {query} (Page {page+1})",
            color=discord.Color.blue()
        )
        for i, r in enumerate(results):
            embed.add_field(name=f"{i+1}. {r['title']}", value=f"[Link]({r['url']})", inline=False)
        return embed

    class SearchView(View):
        def __init__(self):
            super().__init__(timeout=60)
            self.choice = None
            self.page = 0
            self.results = []

        async def load_page(self):
            self.results = await get_results(query, self.page)

        async def update_embed(self, interaction_btn):
            embed = make_embed(self.results, self.page)
            await interaction_btn.message.edit(embed=embed, view=self)

        async def select_song(self, index, interaction_btn):
            if len(self.results) > index:
                self.choice = index
                selected_title = self.results[index]['title']
                await interaction_btn.response.edit_message(
                    content=f"Selected: {selected_title}", embed=None, view=None
                )
                self.stop()

        # Selection buttons
        @discord.ui.button(label="1", style=discord.ButtonStyle.primary)
        async def one(self, interaction_btn, button):
            await self.select_song(0, interaction_btn)

        @discord.ui.button(label="2", style=discord.ButtonStyle.primary)
        async def two(self, interaction_btn, button):
            await self.select_song(1, interaction_btn)

        @discord.ui.button(label="3", style=discord.ButtonStyle.primary)
        async def three(self, interaction_btn, button):
            await self.select_song(2, interaction_btn)

        @discord.ui.button(label="4", style=discord.ButtonStyle.primary)
        async def four(self, interaction_btn, button):
            await self.select_song(3, interaction_btn)

        @discord.ui.button(label="5", style=discord.ButtonStyle.primary)
        async def five(self, interaction_btn, button):
            await self.select_song(4, interaction_btn)

        # Pagination buttons
        @discord.ui.button(label="Previous", style=discord.ButtonStyle.secondary)
        async def previous(self, interaction_btn, button):
            if self.page == 0:
                await interaction_btn.response.send_message("You are on the first page.", ephemeral=True)
                return
            self.page -= 1
            await self.load_page()
            await interaction_btn.response.defer()
            await self.update_embed(interaction_btn)

        @discord.ui.button(label="Next", style=discord.ButtonStyle.secondary)
        async def next(self, interaction_btn, button):
            self.page += 1
            await self.load_page()
            if not self.results:
                self.page -= 1
                await interaction_btn.response.send_message("No more results.", ephemeral=True)
                return
            await interaction_btn.response.defer()
            await self.update_embed(interaction_btn)

        # Cancel button
        @discord.ui.button(label="Cancel", style=discord.ButtonStyle.danger)
        async def cancel(self, interaction_btn, button):
            self.choice = None
            await interaction_btn.response.edit_message(content="Search cancelled.", embed=None, view=None)
            self.stop()

    # Instantiate view and load first page
    view = SearchView()
    await view.load_page()
    await interaction.followup.send(embed=make_embed(view.results, view.page), view=view)
    await view.wait()

    # After selection
    if view.choice is None:
        return  # Cancelled

    selected = view.results[view.choice]
    song_queues[guild_id].append(selected['url'])
    await interaction.followup.send(f"Added to queue: {selected['title']}")

    # Start playback if not playing
    vc = interaction.guild.voice_client
    if not vc or not vc.is_playing():
        await play_next(interaction, guild_id)
# ------------------------
# Play Next Song
# ------------------------
async def play_next(interaction, guild_id):
    if not song_queues[guild_id]:
        song_info_cache[guild_id] = None
        idle_disconnect_times[guild_id] = 0
        return

    url = song_queues[guild_id][0]

    # Extract direct audio URL only (no download)
    with YoutubeDL(YDL_OPTIONS) as ydl:
        try:
            info = ydl.extract_info(url, download=False)
            audio_url = info['url']  # this is the direct audio stream
        except Exception as e:
            await interaction.channel.send(f"Failed to fetch audio: {e}")
            song_queues[guild_id].pop(0)
            return await play_next(interaction, guild_id)

    song_info_cache[guild_id] = {
        'title': info.get('title', 'Unknown'),
        'thumbnail': info.get('thumbnail'),
        'url': url,
        'duration': info.get('duration')
    }

    vc = interaction.guild.voice_client
    if not vc:
        # Connect to user's voice channel
        channel = interaction.user.voice.channel
        vc = await channel.connect()

    volume = volumes.get(guild_id, 1.0)
    source = FFmpegPCMAudio(audio_url, **FFMPEG_OPTIONS)
    vc.play(discord.PCMVolumeTransformer(source, volume=volume),
            after=lambda e: bot.loop.create_task(finish_song(interaction, guild_id)))

    # Send now playing embed
    embed = discord.Embed(
        title="Now Playing",
        description=f"[{song_info_cache[guild_id]['title']}]({url})",
        color=discord.Color.blurple()
    )
    if song_info_cache[guild_id]['thumbnail']:
        embed.set_thumbnail(url=song_info_cache[guild_id]['thumbnail'])
    msg = await interaction.channel.send(embed=embed)
    now_playing_msg[guild_id] = msg
    bot.loop.create_task(update_progress(interaction, guild_id))

# ------------------------
# Update Progress
# ------------------------
async def update_progress(interaction, guild_id):
    msg = now_playing_msg.get(guild_id)
    vc = interaction.guild.voice_client
    info = song_info_cache.get(guild_id)
    if not msg or not vc or not info:
        return

    duration = info.get('duration')
    start_time = asyncio.get_event_loop().time()
    while vc.is_playing():
        elapsed = asyncio.get_event_loop().time() - start_time
        if duration:
            bar_len = 20
            filled_len = min(int((elapsed / duration) * bar_len), bar_len)
            bar = '‚ñà' * filled_len + '‚îÄ' * (bar_len - filled_len)
            progress_text = f"[{bar}] {format_duration(elapsed)} / {format_duration(duration)}"
        else:
            progress_text = "Duration unknown"

        embed = discord.Embed(title="Now Playing",
                              description=f"[{info['title']}]({info['url']})",
                              color=discord.Color.blurple())
        if info['thumbnail']:
            embed.set_thumbnail(url=info['thumbnail'])
        embed.add_field(name="Progress", value=progress_text, inline=False)
        await msg.edit(embed=embed)
        await asyncio.sleep(5)

# ------------------------
# Finish Song
# ------------------------
async def finish_song(interaction, guild_id):
    song_queues[guild_id].pop(0)
    if song_queues[guild_id]:
        await play_next(interaction, guild_id)
    else:
        song_info_cache[guild_id] = None
        idle_disconnect_times[guild_id] = 0

# ------------------------
# Other Commands
# ------------------------
@bot.tree.command(name="skip", description="Skip current song")
async def skip(interaction: discord.Interaction):
    vc = interaction.guild.voice_client
    if vc and vc.is_playing():
        vc.stop()
        await interaction.response.send_message("Skipped!")
    else:
        await interaction.response.send_message("Nothing playing!")

@bot.tree.command(name="pause", description="Pause current song")
async def pause(interaction: discord.Interaction):
    vc = interaction.guild.voice_client
    if vc and vc.is_playing():
        vc.pause()
        await interaction.response.send_message("Paused!")
    else:
        await interaction.response.send_message("Nothing playing!")

@bot.tree.command(name="resume", description="Resume paused song")
async def resume(interaction: discord.Interaction):
    vc = interaction.guild.voice_client
    if vc and vc.is_paused():
        vc.resume()
        await interaction.response.send_message("Resumed!")
    else:
        await interaction.response.send_message("Nothing paused!")

@bot.tree.command(name="volume", description="Set volume 0-100%")
@app_commands.describe(percent="Volume percent")
async def volume(interaction: discord.Interaction, percent: int):
    if not 0 <= percent <= 100:
        await interaction.response.send_message("Volume must be 0-100!")
        return
    guild_id = interaction.guild.id
    volumes[guild_id] = percent / 100
    vc = interaction.guild.voice_client
    if vc and vc.source:
        vc.source.volume = volumes[guild_id]
    await interaction.response.send_message(f"Volume set to {percent}%")

@bot.tree.command(name="remove", description="Remove a song from queue")
@app_commands.describe(position="Position to remove")
async def remove(interaction: discord.Interaction, position: int):
    guild_id = interaction.guild.id
    if guild_id in song_queues and 0 < position <= len(song_queues[guild_id]):
        removed = song_queues[guild_id].pop(position-1)
        await interaction.response.send_message(f"Removed: {removed}")
    else:
        await interaction.response.send_message("Invalid position!")

@bot.tree.command(name="queue", description="Show current queue")
async def queue(interaction: discord.Interaction):
    guild_id = interaction.guild.id
    if guild_id not in song_queues or not song_queues[guild_id]:
        await interaction.response.send_message("Queue is empty!")
        return
    embed = discord.Embed(title="Queue", color=discord.Color.green())
    for i, url in enumerate(song_queues[guild_id]):
        if i == 0 and guild_id in song_info_cache:
            title = song_info_cache[guild_id]['title']
        else:
            title = url
        embed.add_field(name=f"{i+1}.", value=f"[{title}]({url})", inline=False)
    await interaction.response.send_message(embed=embed)

@bot.tree.command(name="nowplaying", description="Show currently playing song")
async def nowplaying(interaction: discord.Interaction):
    guild_id = interaction.guild.id
    info = song_info_cache.get(guild_id)
    if not info:
        await interaction.response.send_message("Nothing is playing!")
        return
    embed = discord.Embed(title="Now Playing",
                          description=f"[{info['title']}]({info['url']})",
                          color=discord.Color.blurple())
    if info.get('thumbnail'):
        embed.set_thumbnail(url=info['thumbnail'])
    embed.add_field(name="Duration", value=format_duration(info.get('duration')), inline=False)
    await interaction.response.send_message(embed=embed)

@bot.tree.command(name="help", description="Show all bot commands")
async def help(interaction: discord.Interaction):
    embed = discord.Embed(title="Music Bot Commands", color=discord.Color.gold())
    embed.add_field(name="/play <URL>", value="Play YouTube or Spotify track/playlist", inline=False)
    embed.add_field(name="/search <query>", value="Search YouTube and choose a song", inline=False)
    embed.add_field(name="/queue", value="Show current queue", inline=False)
    embed.add_field(name="/nowplaying", value="Show currently playing song", inline=False)
    embed.add_field(name="/skip", value="Skip current song", inline=False)
    embed.add_field(name="/pause", value="Pause current song", inline=False)
    embed.add_field(name="/resume", value="Resume paused song", inline=False)
    embed.add_field(name="/volume <0-100>", value="Set volume", inline=False)
    embed.add_field(name="/remove <position>", value="Remove a song from queue", inline=False)
    await interaction.response.send_message(embed=embed)

# ------------------------
# Idle Disconnect
# ------------------------
@tasks.loop(seconds=10)
async def check_idle_disconnect():
    for guild_id in list(song_queues.keys()):
        vc = bot.get_guild(guild_id).voice_client
        if vc and not vc.is_playing():
            idle_disconnect_times[guild_id] = idle_disconnect_times.get(guild_id, 0) + 10
            if idle_disconnect_times[guild_id] >= 120:
                await vc.disconnect()
                idle_disconnect_times[guild_id] = 0
								
# -------------------------------------------------
# GLOBAL GAME + STATS STORAGE
# -------------------------------------------------
rps_games = {}
rps_stats = {}
SAVE_FILE = "rps_stats.json"


# -------------------------------------------------
# HELPERS: SAVE/LOAD STATS
# -------------------------------------------------
def save_stats():
    with open(SAVE_FILE, "w") as f:
        json.dump(rps_stats, f)


def load_stats():
    global rps_stats
    if os.path.exists(SAVE_FILE):
        with open(SAVE_FILE, "r") as f:
            rps_stats.update(json.load(f))


def get_game_key(guild_id, p1_id, p2_id):
    return (guild_id, min(p1_id, p2_id), max(p1_id, p2_id))


def update_stats(winner_id=None, loser_id=None, tie_ids=None):
    if tie_ids:
        for uid in tie_ids:
            rps_stats.setdefault(uid, {"wins": 0, "losses": 0, "ties": 0})
            rps_stats[uid]["ties"] += 1
    else:
        for uid, key in [(winner_id, "wins"), (loser_id, "losses")]:
            rps_stats.setdefault(uid, {"wins": 0, "losses": 0, "ties": 0})
            rps_stats[uid][key] += 1
    save_stats()


# -------------------------------------------------
# /rpscancel
# -------------------------------------------------
@bot.tree.command(name="rpscancel", description="Cancel your current RPS challenge")
@app_commands.describe(opponent="Who you want to cancel the game with")
async def rpscancel(interaction: discord.Interaction, opponent: discord.Member):
    key = get_game_key(interaction.guild.id, interaction.user.id, opponent.id)
    if key in rps_games:
        rps_games.pop(key)
        await interaction.response.send_message("Game cancelled.", ephemeral=True)
    else:
        await interaction.response.send_message("No active game with that user.", ephemeral=True)


# -------------------------------------------------
# /rps - Main Game
# -------------------------------------------------
@bot.tree.command(name="rps", description="Challenge someone to Rock Paper Scissors")
@app_commands.describe(opponent="Who you want to challenge")
async def rps(interaction: discord.Interaction, opponent: discord.Member):
    challenger = interaction.user
    guild = interaction.guild
    gid = guild.id

    if challenger.id == opponent.id:
        return await interaction.response.send_message("You can‚Äôt challenge yourself!", ephemeral=True)

    key = get_game_key(gid, challenger.id, opponent.id)
    if key in rps_games:
        return await interaction.response.send_message("A game between you two already exists!", ephemeral=True)

    rps_games[key] = {"choices": {}}
    choices_map = {"Rock": "ü™®", "Paper": "üìÑ", "Scissors": "‚úÇÔ∏è"}

    # ---------------- Challenger chooses (ephemeral)
    class ChallengerView(discord.ui.View):
        def __init__(self):
            super().__init__(timeout=300)

        async def on_timeout(self):
            rps_games.pop(key, None)
            self.stop()

        async def choice_made(self, ibtn: discord.Interaction, choice: str):
            rps_games[key]["choices"][challenger.id] = choice
            await ibtn.response.send_message(f"You chose {choices_map[choice]}", ephemeral=True)
            self.stop()

    c_view = ChallengerView()
    for opt in ["Rock", "Paper", "Scissors"]:
        btn = discord.ui.Button(label=choices_map[opt], style=discord.ButtonStyle.primary)

        async def cb(ibtn: discord.Interaction, choice=opt):
            if ibtn.user.id != challenger.id:
                return await ibtn.response.send_message("This isn‚Äôt for you.", ephemeral=True)
            await c_view.choice_made(ibtn, choice)

        btn.callback = cb
        c_view.add_item(btn)

    await interaction.response.send_message(
        f"{challenger.mention}, choose your move:", view=c_view, ephemeral=True
    )

    # ---------------- Opponent Accept/Decline (public)
    class AcceptDecline(discord.ui.View):
        def __init__(self):
            super().__init__(timeout=300)

        async def on_timeout(self):
            for c in self.children:
                c.disabled = True
            try:
                await self.message.edit(content="Challenge timed out ‚è∞", view=self)
            except:
                pass
            rps_games.pop(key, None)

        @discord.ui.button(label="Accept", style=discord.ButtonStyle.success)
        async def accept(self, i: discord.Interaction, _):
            if i.user.id != opponent.id:
                return await i.response.send_message("Not your challenge!", ephemeral=True)
            for c in self.children:
                c.disabled = True
            await i.message.edit(view=self)
            await i.response.send_message("Challenge accepted! Check your ephemeral message.", ephemeral=True)
            await send_opponent_choice(i)

        @discord.ui.button(label="Decline", style=discord.ButtonStyle.danger)
        async def decline(self, i: discord.Interaction, _):
            if i.user.id != opponent.id:
                return await i.response.send_message("Not your challenge!", ephemeral=True)
            for c in self.children:
                c.disabled = True
            await i.message.edit(view=self)
            rps_games.pop(key, None)
            await i.response.send_message("Challenge declined.", ephemeral=True)

    view = AcceptDecline()
    msg = await interaction.channel.send(
        f"{opponent.mention}, **{challenger.display_name}** challenged you to Rock Paper Scissors!",
        view=view,
    )
    view.message = msg

    # ---------------- Opponent chooses (ephemeral)
    async def send_opponent_choice(btn_i: discord.Interaction):
        class OpponentView(discord.ui.View):
            def __init__(self):
                super().__init__(timeout=300)

            async def on_timeout(self):
                try:
                    await self.message.edit(content="Game timed out ‚è∞", view=None)
                except Exception:
                    pass
                rps_games.pop(key, None)
                self.stop()

            async def choice_made(self, ibtn: discord.Interaction, choice: str):
                rps_games[key]["choices"][opponent.id] = choice
                await ibtn.response.send_message(f"You chose {choices_map[choice]}", ephemeral=True)
                self.stop()

                choices = rps_games[key]["choices"]
                if len(choices) == 2:
                    p1_id, p2_id = key[1], key[2]
                    p1 = guild.get_member(p1_id) or await bot.fetch_user(p1_id)
                    p2 = guild.get_member(p2_id) or await bot.fetch_user(p2_id)

                    if not p1 or not p2:
                        await btn_i.channel.send("Error resolving players. Game cancelled.")
                        rps_games.pop(key, None)
                        return

                    p1c, p2c = choices[p1_id], choices[p2_id]
                    if p1c == p2c:
                        res = f"It's a tie! You both picked {choices_map[p1c]}"
                        update_stats(tie_ids=[p1_id, p2_id])
                    elif (
                        (p1c == "Rock" and p2c == "Scissors")
                        or (p1c == "Paper" and p2c == "Rock")
                        or (p1c == "Scissors" and p2c == "Paper")
                    ):
                        res = f"{p1.mention} wins! {choices_map[p1c]} beats {choices_map[p2c]}"
                        update_stats(winner_id=p1_id, loser_id=p2_id)
                    else:
                        res = f"{p2.mention} wins! {choices_map[p2c]} beats {choices_map[p1c]}"
                        update_stats(winner_id=p2_id, loser_id=p1_id)

                    await btn_i.channel.send(res)
                    rps_games.pop(key, None)

        o_view = OpponentView()
        for opt in ["Rock", "Paper", "Scissors"]:
            btn = discord.ui.Button(label=choices_map[opt], style=discord.ButtonStyle.primary)

            async def cb(ibtn: discord.Interaction, choice=opt):
                if ibtn.user.id != opponent.id:
                    return await ibtn.response.send_message("Not your challenge.", ephemeral=True)
                await o_view.choice_made(ibtn, choice)

            btn.callback = cb
            o_view.add_item(btn)

        msg = await btn_i.followup.send(
            f"{opponent.mention}, choose your move:", view=o_view, ephemeral=True
        )
        o_view.message = msg


# -------------------------------------------------
# /rpsstats - Player Stats
# -------------------------------------------------
@bot.tree.command(name="rpsstats", description="View your or another player's RPS stats")
@app_commands.describe(member="Optional member to view")
async def rpsstats(interaction: discord.Interaction, member: discord.Member = None):
    user = member or interaction.user
    if user.id not in rps_stats:
        return await interaction.response.send_message(f"{user.mention} has no recorded games yet.", ephemeral=True)
    s = rps_stats[user.id]
    embed = discord.Embed(title=f"ü™®üìÑ‚úÇÔ∏è RPS Stats ‚Äî {user.display_name}", color=discord.Color.blurple())
    embed.add_field(name="Wins", value=s["wins"])
    embed.add_field(name="Losses", value=s["losses"])
    embed.add_field(name="Ties", value=s["ties"])
    await interaction.response.send_message(embed=embed, ephemeral=True)


# -------------------------------------------------
# /rpsleaderboard - Paginated with medals + ‚ÄúYou‚Äù line
# -------------------------------------------------
@bot.tree.command(name="rpsleaderboard", description="Show the RPS leaderboard")
async def rpsleaderboard(interaction: discord.Interaction):
    if not rps_stats:
        return await interaction.response.send_message("No games played yet.", ephemeral=True)

    sorted_stats = sorted(rps_stats.items(), key=lambda x: (x[1]["wins"], x[1]["ties"]), reverse=True)
    page_size = 10
    total_pages = (len(sorted_stats) + page_size - 1) // page_size

    def get_user_rank(uid):
        for idx, (user_id, s) in enumerate(sorted_stats, start=1):
            if user_id == uid:
                return idx, s
        return None, None

    def rank_icon(rank):
        return "ü•á" if rank == 1 else "ü•à" if rank == 2 else "ü•â" if rank == 3 else f"{rank}."

    def create_page(page: int, viewer_id: int):
        start, end = page * page_size, page * page_size + page_size
        page_data = sorted_stats[start:end]
        desc = ""
        for i, (uid, s) in enumerate(page_data, start=start + 1):
            m = interaction.guild.get_member(uid)
            name = m.display_name if m else f"User {uid}"
            desc += f"**{rank_icon(i)} {name}** ‚Äî üèÜ {s['wins']}W / ‚ùå {s['losses']}L / ü§ù {s['ties']}T\n"

        v_rank, v_stats = get_user_rank(viewer_id)
        if v_rank and not (start < v_rank <= end):
            desc += f"\n‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî\n**You (#{v_rank})** ‚Äî üèÜ {v_stats['wins']}W / ‚ùå {v_stats['losses']}L / ü§ù {v_stats['ties']}T\n"

        embed = discord.Embed(title="üèÜ Rock Paper Scissors Leaderboard", description=desc, color=discord.Color.gold())
        embed.set_footer(text=f"Page {page + 1} of {total_pages}")
        return embed

    class LeaderboardView(discord.ui.View):
        def __init__(self, viewer_id):
            super().__init__(timeout=60)
            self.page = 0
            self.viewer_id = viewer_id

        async def update(self, i: discord.Interaction):
            await i.response.edit_message(embed=create_page(self.page, self.viewer_id), view=self)

        @discord.ui.button(label="‚èÆÔ∏è Prev", style=discord.ButtonStyle.secondary)
        async def prev(self, i: discord.Interaction, _):
            if self.page > 0:
                self.page -= 1
                await self.update(i)
            else:
                await i.response.defer()

        @discord.ui.button(label="‚è≠Ô∏è Next", style=discord.ButtonStyle.secondary)
        async def next(self, i: discord.Interaction, _):
            if self.page < total_pages - 1:
                self.page += 1
                await self.update(i)
            else:
                await i.response.defer()

        async def on_timeout(self):
            for c in self.children:
                c.disabled = True
            try:
                await self.message.edit(view=self)
            except:
                pass

    view = LeaderboardView(interaction.user.id)
    embed = create_page(0, interaction.user.id)
    await interaction.response.send_message(embed=embed, view=view)
    view.message = await interaction.original_response()


# ------------------------
# jamesjoke
# ------------------------
@bot.tree.command(name="jamesjoke", description="Get a random James joke")
async def jamesjoke(interaction: discord.Interaction):
    with open("jokes.txt", "r", encoding="utf-8") as f:
        jokes = [line.strip() for line in f if line.strip()]
    await interaction.response.send_message(random.choice(jokes))
		
# ------------------------
# Ready Event (restore all commands)
# ------------------------
@bot.event
async def on_ready():
    await bot.wait_until_ready()

    print("Connected guilds:", [f"{g.name} ({g.id})" for g in bot.guilds])
    print(f"Commands registered: {[cmd.name for cmd in bot.tree.get_commands()]}")

    guild_id = 1435711020680347688
    guild = discord.utils.get(bot.guilds, id=guild_id)

    try:
        if guild:
            # Repopulate the guild from local tree
            bot.tree.clear_commands(guild=guild)
            bot.tree.copy_global_to(guild=guild)
            synced = await bot.tree.sync(guild=guild)
            print(f"‚úÖ Restored {len(synced)} commands to guild {guild.name}")
        else:
            print("‚ö†Ô∏è Guild not found; syncing globally instead.")
            synced = await bot.tree.sync()
            print(f"‚úÖ Restored {len(synced)} global commands")

        for cmd in synced:
            print(f" - /{cmd.name}")

    except Exception as e:
        print(f"‚ùå Error syncing commands: {e}")

    if not check_idle_disconnect.is_running():
        check_idle_disconnect.start()

    print(f"Logged in as {bot.user}")

# ------------------------
# Run Bot
# ------------------------


